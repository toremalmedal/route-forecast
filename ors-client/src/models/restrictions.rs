/*
 * Openrouteservice
 *
 * This is the openrouteservice API documentation for ORS Core-Version 9.5.0. Documentations for [older Core-Versions](https://github.com/GIScience/openrouteservice-docs/releases) can be rendered with the [Swagger-Editor](https://editor-next.swagger.io/).
 *
 * The version of the OpenAPI document: v2
 * Contact: support@smartmobility.heigit.org
 * Generated by: https://openapi-generator.tech
 */

use crate::models;
use serde::{Deserialize, Serialize};

/// Restrictions : Describe restrictions to be applied to edges on the routing. any edges that do not match these restrictions are not traversed.
#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct Restrictions {
    /// Length restriction in metres.
    #[serde(rename = "length", skip_serializing_if = "Option::is_none")]
    pub length: Option<f32>,
    /// Width restriction in metres.
    #[serde(rename = "width", skip_serializing_if = "Option::is_none")]
    pub width: Option<f32>,
    /// Height restriction in metres. 
    #[serde(rename = "height", skip_serializing_if = "Option::is_none")]
    pub height: Option<f32>,
    /// Axleload restriction in tons.
    #[serde(rename = "axleload", skip_serializing_if = "Option::is_none")]
    pub axleload: Option<f32>,
    /// Weight restriction in tons. 
    #[serde(rename = "weight", skip_serializing_if = "Option::is_none")]
    pub weight: Option<f32>,
    /// Specifies whether to use appropriate routing for delivering hazardous goods and avoiding water protected areas. Default is `false`. 
    #[serde(rename = "hazmat", skip_serializing_if = "Option::is_none")]
    pub hazmat: Option<bool>,
    /// Specifies the minimum surface type. Default is `sett`. 
    #[serde(rename = "surface_type", skip_serializing_if = "Option::is_none")]
    pub surface_type: Option<String>,
    /// Specifies the minimum grade of the route. Default is `grade1`. 
    #[serde(rename = "track_type", skip_serializing_if = "Option::is_none")]
    pub track_type: Option<String>,
    /// Specifies the minimum smoothness of the route. Default is `good`.
    #[serde(rename = "smoothness_type", skip_serializing_if = "Option::is_none")]
    pub smoothness_type: Option<SmoothnessType>,
    /// Specifies the maximum height of the sloped curb in metres. Values are `0.03`, `0.06` (default), `0.1`.
    #[serde(rename = "maximum_sloped_kerb", skip_serializing_if = "Option::is_none")]
    pub maximum_sloped_kerb: Option<f32>,
    /// Specifies the maximum incline as a percentage. `3`, `6` (default), `10`, `15.
    #[serde(rename = "maximum_incline", skip_serializing_if = "Option::is_none")]
    pub maximum_incline: Option<i32>,
    /// Specifies the minimum width of the footway in metres.
    #[serde(rename = "minimum_width", skip_serializing_if = "Option::is_none")]
    pub minimum_width: Option<f32>,
}

impl Restrictions {
    /// Describe restrictions to be applied to edges on the routing. any edges that do not match these restrictions are not traversed.
    pub fn new() -> Restrictions {
        Restrictions {
            length: None,
            width: None,
            height: None,
            axleload: None,
            weight: None,
            hazmat: None,
            surface_type: None,
            track_type: None,
            smoothness_type: None,
            maximum_sloped_kerb: None,
            maximum_incline: None,
            minimum_width: None,
        }
    }
}
/// Specifies the minimum smoothness of the route. Default is `good`.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum SmoothnessType {
    #[serde(rename = "excellent")]
    Excellent,
    #[serde(rename = "good")]
    Good,
    #[serde(rename = "intermediate")]
    Intermediate,
    #[serde(rename = "bad")]
    Bad,
    #[serde(rename = "very_bad")]
    VeryBad,
    #[serde(rename = "horrible")]
    Horrible,
    #[serde(rename = "very_horrible")]
    VeryHorrible,
    #[serde(rename = "impassable")]
    Impassable,
}

impl Default for SmoothnessType {
    fn default() -> SmoothnessType {
        Self::Excellent
    }
}

