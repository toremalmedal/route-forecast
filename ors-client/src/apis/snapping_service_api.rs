/*
 * Openrouteservice
 *
 * This is the openrouteservice API documentation for ORS Core-Version 9.5.0. Documentations for [older Core-Versions](https://github.com/GIScience/openrouteservice-docs/releases) can be rendered with the [Swagger-Editor](https://editor-next.swagger.io/).
 *
 * The version of the OpenAPI document: v2
 * Contact: support@smartmobility.heigit.org
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`get_default`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDefaultError {
    Status400(serde_json::Value),
    Status404(serde_json::Value),
    Status405(serde_json::Value),
    Status413(serde_json::Value),
    Status500(serde_json::Value),
    Status501(serde_json::Value),
    Status503(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_geo_json_snapping`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGeoJsonSnappingError {
    Status400(serde_json::Value),
    Status404(serde_json::Value),
    Status405(serde_json::Value),
    Status413(serde_json::Value),
    Status500(serde_json::Value),
    Status501(serde_json::Value),
    Status503(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_json_snapping`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetJsonSnappingError {
    Status400(serde_json::Value),
    Status404(serde_json::Value),
    Status405(serde_json::Value),
    Status413(serde_json::Value),
    Status500(serde_json::Value),
    Status501(serde_json::Value),
    Status503(serde_json::Value),
    UnknownValue(serde_json::Value),
}


/// Returns a list of points snapped to the nearest edge in the routing graph. In case an appropriate snapping point cannot be found within the specified search radius, \"null\" is returned. 
pub async fn get_default(configuration: &configuration::Configuration, profile: &str, get_default_request: models::GetDefaultRequest) -> Result<models::GetDefault200Response, Error<GetDefaultError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_profile = profile;
    let p_body_get_default_request = get_default_request;

    let uri_str = format!("{}/v2/snap/{profile}", configuration.base_path, profile=crate::apis::urlencode(p_path_profile));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_get_default_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetDefault200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetDefault200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDefaultError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a GeoJSON FeatureCollection of points snapped to the nearest edge in the routing graph. In case an appropriate snapping point cannot be found within the specified search radius, it is omitted from the features array. The features provide the 'source_id' property, to match the results with the input location array (IDs start at 0). 
pub async fn get_geo_json_snapping(configuration: &configuration::Configuration, profile: &str, get_default_request: models::GetDefaultRequest) -> Result<models::GetGeoJsonSnapping200Response, Error<GetGeoJsonSnappingError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_profile = profile;
    let p_body_get_default_request = get_default_request;

    let uri_str = format!("{}/v2/snap/{profile}/geojson", configuration.base_path, profile=crate::apis::urlencode(p_path_profile));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_get_default_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetGeoJsonSnapping200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetGeoJsonSnapping200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetGeoJsonSnappingError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a list of points snapped to the nearest edge in the routing graph. In case an appropriate snapping point cannot be found within the specified search radius, \"null\" is returned. 
pub async fn get_json_snapping(configuration: &configuration::Configuration, profile: &str, get_default_request: models::GetDefaultRequest) -> Result<models::GetDefault200Response, Error<GetJsonSnappingError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_profile = profile;
    let p_body_get_default_request = get_default_request;

    let uri_str = format!("{}/v2/snap/{profile}/json", configuration.base_path, profile=crate::apis::urlencode(p_path_profile));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_get_default_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetDefault200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetDefault200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetJsonSnappingError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

