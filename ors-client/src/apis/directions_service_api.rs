/*
 * Openrouteservice
 *
 * This is the openrouteservice API documentation for ORS Core-Version 9.5.0. Documentations for [older Core-Versions](https://github.com/GIScience/openrouteservice-docs/releases) can be rendered with the [Swagger-Editor](https://editor-next.swagger.io/).
 *
 * The version of the OpenAPI document: v2
 * Contact: support@smartmobility.heigit.org
 * Generated by: https://openapi-generator.tech
 */


use async_trait::async_trait;
#[cfg(feature = "mockall")]
use mockall::automock;
use reqwest;
use std::sync::Arc;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};
use crate::apis::ContentType;

#[cfg_attr(feature = "mockall", automock)]
#[async_trait]
pub trait DirectionsServiceApi: Send + Sync {

    /// POST /v2/directions/{profile}
    ///
    /// Returns a route between two or more locations for a selected profile and its settings as JSON
    async fn get_default3<'profile, 'directions_service>(&self, profile: &'profile str, directions_service: models::DirectionsService) -> Result<models::GetDefault3200Response, Error<GetDefault3Error>>;

    /// POST /v2/directions/{profile}/geojson
    ///
    /// Returns a route between two or more locations for a selected profile and its settings as GeoJSON
    async fn get_geo_json_route<'profile, 'directions_service>(&self, profile: &'profile str, directions_service: models::DirectionsService) -> Result<models::GetSimpleGeoJsonRoute200Response, Error<GetGeoJsonRouteError>>;

    /// POST /v2/directions/{profile}/gpx
    ///
    /// Returns a route between two or more locations for a selected profile and its settings as GPX. The schema can be found [here](https://raw.githubusercontent.com/GIScience/openrouteservice-schema/main/gpx/v1/ors-gpx.xsd)
    async fn get_gpx_route<'profile, 'directions_service>(&self, profile: &'profile str, directions_service: models::DirectionsService) -> Result<models::GetGpxRoute200Response, Error<GetGpxRouteError>>;

    /// POST /v2/directions/{profile}/json
    ///
    /// Returns a route between two or more locations for a selected profile and its settings as JSON
    async fn get_json_route<'profile, 'directions_service>(&self, profile: &'profile str, directions_service: models::DirectionsService) -> Result<models::GetDefault3200Response, Error<GetJsonRouteError>>;

    /// GET /v2/directions/{profile}
    ///
    /// Get a basic route between two points with the profile provided. Returned response is in GeoJSON format. This method does not accept any request body or parameters other than profile, start coordinate, and end coordinate.
    async fn get_simple_geo_json_route<'profile, 'start, 'end>(&self, profile: &'profile str, start: &'start str, end: &'end str) -> Result<models::GetSimpleGeoJsonRoute200Response, Error<GetSimpleGeoJsonRouteError>>;
}

pub struct DirectionsServiceApiClient {
    configuration: Arc<configuration::Configuration>
}

impl DirectionsServiceApiClient {
    pub fn new(configuration: Arc<configuration::Configuration>) -> Self {
        Self { configuration }
    }
}



#[async_trait]
impl DirectionsServiceApi for DirectionsServiceApiClient {
    /// Returns a route between two or more locations for a selected profile and its settings as JSON
    async fn get_default3<'profile, 'directions_service>(&self, profile: &'profile str, directions_service: models::DirectionsService) -> Result<models::GetDefault3200Response, Error<GetDefault3Error>> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/v2/directions/{profile}", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        local_var_req_builder = local_var_req_builder.json(&directions_service);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetDefault3200Response`"))),
                ContentType::Unsupported(local_var_unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{local_var_unknown_type}` content type response that cannot be converted to `models::GetDefault3200Response`")))),
            }
        } else {
            let local_var_entity: Option<GetDefault3Error> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Returns a route between two or more locations for a selected profile and its settings as GeoJSON
    async fn get_geo_json_route<'profile, 'directions_service>(&self, profile: &'profile str, directions_service: models::DirectionsService) -> Result<models::GetSimpleGeoJsonRoute200Response, Error<GetGeoJsonRouteError>> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/v2/directions/{profile}/geojson", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        local_var_req_builder = local_var_req_builder.json(&directions_service);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetSimpleGeoJsonRoute200Response`"))),
                ContentType::Unsupported(local_var_unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{local_var_unknown_type}` content type response that cannot be converted to `models::GetSimpleGeoJsonRoute200Response`")))),
            }
        } else {
            let local_var_entity: Option<GetGeoJsonRouteError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Returns a route between two or more locations for a selected profile and its settings as GPX. The schema can be found [here](https://raw.githubusercontent.com/GIScience/openrouteservice-schema/main/gpx/v1/ors-gpx.xsd)
    async fn get_gpx_route<'profile, 'directions_service>(&self, profile: &'profile str, directions_service: models::DirectionsService) -> Result<models::GetGpxRoute200Response, Error<GetGpxRouteError>> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/v2/directions/{profile}/gpx", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        local_var_req_builder = local_var_req_builder.json(&directions_service);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetGpxRoute200Response`"))),
                ContentType::Unsupported(local_var_unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{local_var_unknown_type}` content type response that cannot be converted to `models::GetGpxRoute200Response`")))),
            }
        } else {
            let local_var_entity: Option<GetGpxRouteError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Returns a route between two or more locations for a selected profile and its settings as JSON
    async fn get_json_route<'profile, 'directions_service>(&self, profile: &'profile str, directions_service: models::DirectionsService) -> Result<models::GetDefault3200Response, Error<GetJsonRouteError>> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/v2/directions/{profile}/json", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        local_var_req_builder = local_var_req_builder.json(&directions_service);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetDefault3200Response`"))),
                ContentType::Unsupported(local_var_unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{local_var_unknown_type}` content type response that cannot be converted to `models::GetDefault3200Response`")))),
            }
        } else {
            let local_var_entity: Option<GetJsonRouteError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Get a basic route between two points with the profile provided. Returned response is in GeoJSON format. This method does not accept any request body or parameters other than profile, start coordinate, and end coordinate.
    async fn get_simple_geo_json_route<'profile, 'start, 'end>(&self, profile: &'profile str, start: &'start str, end: &'end str) -> Result<models::GetSimpleGeoJsonRoute200Response, Error<GetSimpleGeoJsonRouteError>> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/v2/directions/{profile}", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        local_var_req_builder = local_var_req_builder.query(&[("start", &start.to_string())]);
        local_var_req_builder = local_var_req_builder.query(&[("end", &end.to_string())]);
        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetSimpleGeoJsonRoute200Response`"))),
                ContentType::Unsupported(local_var_unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{local_var_unknown_type}` content type response that cannot be converted to `models::GetSimpleGeoJsonRoute200Response`")))),
            }
        } else {
            let local_var_entity: Option<GetSimpleGeoJsonRouteError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

}

/// struct for typed errors of method [`DirectionsServiceApi::get_default3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDefault3Error {
    Status400(serde_json::Value),
    Status404(serde_json::Value),
    Status405(serde_json::Value),
    Status413(serde_json::Value),
    Status500(serde_json::Value),
    Status501(serde_json::Value),
    Status503(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`DirectionsServiceApi::get_geo_json_route`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGeoJsonRouteError {
    Status400(serde_json::Value),
    Status404(serde_json::Value),
    Status405(serde_json::Value),
    Status413(serde_json::Value),
    Status500(serde_json::Value),
    Status501(serde_json::Value),
    Status503(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`DirectionsServiceApi::get_gpx_route`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGpxRouteError {
    Status400(serde_json::Value),
    Status404(serde_json::Value),
    Status405(serde_json::Value),
    Status413(serde_json::Value),
    Status500(serde_json::Value),
    Status501(serde_json::Value),
    Status503(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`DirectionsServiceApi::get_json_route`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetJsonRouteError {
    Status400(serde_json::Value),
    Status404(serde_json::Value),
    Status405(serde_json::Value),
    Status413(serde_json::Value),
    Status500(serde_json::Value),
    Status501(serde_json::Value),
    Status503(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`DirectionsServiceApi::get_simple_geo_json_route`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSimpleGeoJsonRouteError {
    Status400(serde_json::Value),
    Status404(serde_json::Value),
    Status405(serde_json::Value),
    Status413(serde_json::Value),
    Status500(serde_json::Value),
    Status501(serde_json::Value),
    Status503(serde_json::Value),
    UnknownValue(serde_json::Value),
}

