/*
 * Openrouteservice
 *
 * This is the openrouteservice API documentation for ORS Core-Version 9.5.0. Documentations for [older Core-Versions](https://github.com/GIScience/openrouteservice-docs/releases) can be rendered with the [Swagger-Editor](https://editor-next.swagger.io/).
 *
 * The version of the OpenAPI document: v2
 * Contact: support@smartmobility.heigit.org
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`get_default3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDefault3Error {
    Status400(serde_json::Value),
    Status404(serde_json::Value),
    Status405(serde_json::Value),
    Status413(serde_json::Value),
    Status500(serde_json::Value),
    Status501(serde_json::Value),
    Status503(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_geo_json_route`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGeoJsonRouteError {
    Status400(serde_json::Value),
    Status404(serde_json::Value),
    Status405(serde_json::Value),
    Status413(serde_json::Value),
    Status500(serde_json::Value),
    Status501(serde_json::Value),
    Status503(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_gpx_route`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGpxRouteError {
    Status400(serde_json::Value),
    Status404(serde_json::Value),
    Status405(serde_json::Value),
    Status413(serde_json::Value),
    Status500(serde_json::Value),
    Status501(serde_json::Value),
    Status503(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_json_route`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetJsonRouteError {
    Status400(serde_json::Value),
    Status404(serde_json::Value),
    Status405(serde_json::Value),
    Status413(serde_json::Value),
    Status500(serde_json::Value),
    Status501(serde_json::Value),
    Status503(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_simple_geo_json_route`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSimpleGeoJsonRouteError {
    Status400(serde_json::Value),
    Status404(serde_json::Value),
    Status405(serde_json::Value),
    Status413(serde_json::Value),
    Status500(serde_json::Value),
    Status501(serde_json::Value),
    Status503(serde_json::Value),
    UnknownValue(serde_json::Value),
}


/// Returns a route between two or more locations for a selected profile and its settings as JSON
pub async fn get_default3(configuration: &configuration::Configuration, profile: &str, directions_service: models::DirectionsService) -> Result<models::GetDefault3200Response, Error<GetDefault3Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_profile = profile;
    let p_body_directions_service = directions_service;

    let uri_str = format!("{}/v2/directions/{profile}", configuration.base_path, profile=crate::apis::urlencode(p_path_profile));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_directions_service);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetDefault3200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetDefault3200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDefault3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a route between two or more locations for a selected profile and its settings as GeoJSON
pub async fn get_geo_json_route(configuration: &configuration::Configuration, profile: &str, directions_service: models::DirectionsService) -> Result<models::GetSimpleGeoJsonRoute200Response, Error<GetGeoJsonRouteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_profile = profile;
    let p_body_directions_service = directions_service;

    let uri_str = format!("{}/v2/directions/{profile}/geojson", configuration.base_path, profile=crate::apis::urlencode(p_path_profile));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_directions_service);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetSimpleGeoJsonRoute200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetSimpleGeoJsonRoute200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetGeoJsonRouteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a route between two or more locations for a selected profile and its settings as GPX. The schema can be found [here](https://raw.githubusercontent.com/GIScience/openrouteservice-schema/main/gpx/v1/ors-gpx.xsd)
pub async fn get_gpx_route(configuration: &configuration::Configuration, profile: &str, directions_service: models::DirectionsService) -> Result<models::GetGpxRoute200Response, Error<GetGpxRouteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_profile = profile;
    let p_body_directions_service = directions_service;

    let uri_str = format!("{}/v2/directions/{profile}/gpx", configuration.base_path, profile=crate::apis::urlencode(p_path_profile));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_directions_service);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetGpxRoute200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetGpxRoute200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetGpxRouteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a route between two or more locations for a selected profile and its settings as JSON
pub async fn get_json_route(configuration: &configuration::Configuration, profile: &str, directions_service: models::DirectionsService) -> Result<models::GetDefault3200Response, Error<GetJsonRouteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_profile = profile;
    let p_body_directions_service = directions_service;

    let uri_str = format!("{}/v2/directions/{profile}/json", configuration.base_path, profile=crate::apis::urlencode(p_path_profile));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_directions_service);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetDefault3200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetDefault3200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetJsonRouteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a basic route between two points with the profile provided. Returned response is in GeoJSON format. This method does not accept any request body or parameters other than profile, start coordinate, and end coordinate.
pub async fn get_simple_geo_json_route(configuration: &configuration::Configuration, profile: &str, start: &str, end: &str) -> Result<models::GetSimpleGeoJsonRoute200Response, Error<GetSimpleGeoJsonRouteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_profile = profile;
    let p_query_start = start;
    let p_query_end = end;

    let uri_str = format!("{}/v2/directions/{profile}", configuration.base_path, profile=crate::apis::urlencode(p_path_profile));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("start", &p_query_start.to_string())]);
    req_builder = req_builder.query(&[("end", &p_query_end.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetSimpleGeoJsonRoute200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetSimpleGeoJsonRoute200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSimpleGeoJsonRouteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

