/*
 * Openrouteservice
 *
 * This is the openrouteservice API documentation for ORS Core-Version 9.5.0. Documentations for [older Core-Versions](https://github.com/GIScience/openrouteservice-docs/releases) can be rendered with the [Swagger-Editor](https://editor-next.swagger.io/).
 *
 * The version of the OpenAPI document: v2
 * Contact: support@smartmobility.heigit.org
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`get_default_isochrones`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDefaultIsochronesError {
    Status400(serde_json::Value),
    Status404(serde_json::Value),
    Status405(serde_json::Value),
    Status413(serde_json::Value),
    Status500(serde_json::Value),
    Status501(serde_json::Value),
    Status503(serde_json::Value),
    UnknownValue(serde_json::Value),
}


/// The Isochrone Service supports time and distance analyses for one single or multiple locations. You may also specify the isochrone interval or provide multiple exact isochrone range values. This service allows the same range of profile options as the /directions endpoint, which help you to further customize your request to obtain a more detailed reachability area response.
pub async fn get_default_isochrones(configuration: &configuration::Configuration, profile: &str, get_default_isochrones_request: models::GetDefaultIsochronesRequest) -> Result<models::GetDefaultIsochrones200Response, Error<GetDefaultIsochronesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_profile = profile;
    let p_body_get_default_isochrones_request = get_default_isochrones_request;

    let uri_str = format!("{}/v2/isochrones/{profile}", configuration.base_path, profile=crate::apis::urlencode(p_path_profile));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_get_default_isochrones_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetDefaultIsochrones200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetDefaultIsochrones200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDefaultIsochronesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

