/*
 * Kartverkets åpne API for søk etter stedsnavn
 *
 *  API for søk etter stedsnavn. Man kan for eksempel søke etter et navn, et sted (et sted kan ha flere navn) eller steder i nærheten av et punkt. APIet returnerer kun de første 5000 resultatene.  Det er ikke nødvendig med innlogging/autorisasjon for å bruke APIet.  Medio desember 2023 ble APIet flyttet til et nytt endepunkt som er tilgjengelig på <a href=\"https://api.kartverket.no/stedsnavn/v1\">https://api.kartverket.no/stedsnavn/v1</a>. Det tidligere endepunktet <a href=\"https://ws.geonorge.no/stedsnavn/v1\">https://ws.geonorge.no/stedsnavn/v1</a> vil være tilgjengelig inntil videre, og vil fungere som en proxy til det nye endepunktet. Vi anbefaler likevel å bytte til det nye endepunktet.  Større eller ikke-kompatible endringer i APIet vil bli annonsert med minst 3 måneder forvarsel på <a href=\"https://status.kartverket.no\">https://status.kartverket.no</a>.     
 *
 * The version of the OpenAPI document: 1.1
 * 
 * Generated by: https://openapi-generator.tech
 */


use async_trait::async_trait;
#[cfg(feature = "mockall")]
use mockall::automock;
use reqwest;
use std::sync::Arc;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};
use crate::apis::ContentType;

#[cfg_attr(feature = "mockall", automock)]
#[async_trait]
pub trait DefaultApi: Send + Sync {

    /// GET /sted
    ///
    /// Søk etter et sted. Et sted kan ha flere stedsnavn, hvert navn kan ha flere skrivemåter. Returen er sortert etter stedets kategorisering innenfor Sentralt stedsnavnsregister (et fylke kommer f.eks. før en bekk). Innenfor hver kategori er så returen sortert etter hvor godt det matcher søkebegrepet. <p>For eksempel ?sok=Trondheim*&knr=5001</p>
    async fn sted_get<'sok, 'fuzzy, 'fnr, 'knr, 'kommunenavn, 'fylkesnavn, 'stedsnummer, 'navneobjekttype, 'utkoordsys, 'treff_per_side, 'side, 'filtrer>(&self, sok: Option<&'sok str>, fuzzy: Option<bool>, fnr: Option<Vec<String>>, knr: Option<Vec<String>>, kommunenavn: Option<&'kommunenavn str>, fylkesnavn: Option<&'fylkesnavn str>, stedsnummer: Option<i32>, navneobjekttype: Option<Vec<String>>, utkoordsys: Option<i32>, treff_per_side: Option<i32>, side: Option<i32>, filtrer: Option<&'filtrer str>) -> Result<models::ReturSted, Error<StedGetError>>;
}

pub struct DefaultApiClient {
    configuration: Arc<configuration::Configuration>
}

impl DefaultApiClient {
    pub fn new(configuration: Arc<configuration::Configuration>) -> Self {
        Self { configuration }
    }
}



#[async_trait]
impl DefaultApi for DefaultApiClient {
    /// Søk etter et sted. Et sted kan ha flere stedsnavn, hvert navn kan ha flere skrivemåter. Returen er sortert etter stedets kategorisering innenfor Sentralt stedsnavnsregister (et fylke kommer f.eks. før en bekk). Innenfor hver kategori er så returen sortert etter hvor godt det matcher søkebegrepet. <p>For eksempel ?sok=Trondheim*&knr=5001</p>
    async fn sted_get<'sok, 'fuzzy, 'fnr, 'knr, 'kommunenavn, 'fylkesnavn, 'stedsnummer, 'navneobjekttype, 'utkoordsys, 'treff_per_side, 'side, 'filtrer>(&self, sok: Option<&'sok str>, fuzzy: Option<bool>, fnr: Option<Vec<String>>, knr: Option<Vec<String>>, kommunenavn: Option<&'kommunenavn str>, fylkesnavn: Option<&'fylkesnavn str>, stedsnummer: Option<i32>, navneobjekttype: Option<Vec<String>>, utkoordsys: Option<i32>, treff_per_side: Option<i32>, side: Option<i32>, filtrer: Option<&'filtrer str>) -> Result<models::ReturSted, Error<StedGetError>> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/sted", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref param_value) = sok {
            local_var_req_builder = local_var_req_builder.query(&[("sok", &param_value.to_string())]);
        }
        if let Some(ref param_value) = fuzzy {
            local_var_req_builder = local_var_req_builder.query(&[("fuzzy", &param_value.to_string())]);
        }
        if let Some(ref param_value) = fnr {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(&param_value.into_iter().map(|p| ("fnr".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
                _ => local_var_req_builder.query(&[("fnr", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
            };
        }
        if let Some(ref param_value) = knr {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(&param_value.into_iter().map(|p| ("knr".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
                _ => local_var_req_builder.query(&[("knr", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
            };
        }
        if let Some(ref param_value) = kommunenavn {
            local_var_req_builder = local_var_req_builder.query(&[("kommunenavn", &param_value.to_string())]);
        }
        if let Some(ref param_value) = fylkesnavn {
            local_var_req_builder = local_var_req_builder.query(&[("fylkesnavn", &param_value.to_string())]);
        }
        if let Some(ref param_value) = stedsnummer {
            local_var_req_builder = local_var_req_builder.query(&[("stedsnummer", &param_value.to_string())]);
        }
        if let Some(ref param_value) = navneobjekttype {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(&param_value.into_iter().map(|p| ("navneobjekttype".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
                _ => local_var_req_builder.query(&[("navneobjekttype", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
            };
        }
        if let Some(ref param_value) = utkoordsys {
            local_var_req_builder = local_var_req_builder.query(&[("utkoordsys", &param_value.to_string())]);
        }
        if let Some(ref param_value) = treff_per_side {
            local_var_req_builder = local_var_req_builder.query(&[("treffPerSide", &param_value.to_string())]);
        }
        if let Some(ref param_value) = side {
            local_var_req_builder = local_var_req_builder.query(&[("side", &param_value.to_string())]);
        }
        if let Some(ref param_value) = filtrer {
            local_var_req_builder = local_var_req_builder.query(&[("filtrer", &param_value.to_string())]);
        }
        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ReturSted`"))),
                ContentType::Unsupported(local_var_unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{local_var_unknown_type}` content type response that cannot be converted to `models::ReturSted`")))),
            }
        } else {
            let local_var_entity: Option<StedGetError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

}

/// struct for typed errors of method [`DefaultApi::sted_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StedGetError {
    UnknownValue(serde_json::Value),
}

