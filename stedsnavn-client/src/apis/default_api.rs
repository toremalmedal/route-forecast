/*
 * Kartverkets åpne API for søk etter stedsnavn
 *
 *  API for søk etter stedsnavn. Man kan for eksempel søke etter et navn, et sted (et sted kan ha flere navn) eller steder i nærheten av et punkt. APIet returnerer kun de første 5000 resultatene.  Det er ikke nødvendig med innlogging/autorisasjon for å bruke APIet.  Medio desember 2023 ble APIet flyttet til et nytt endepunkt som er tilgjengelig på <a href=\"https://api.kartverket.no/stedsnavn/v1\">https://api.kartverket.no/stedsnavn/v1</a>. Det tidligere endepunktet <a href=\"https://ws.geonorge.no/stedsnavn/v1\">https://ws.geonorge.no/stedsnavn/v1</a> vil være tilgjengelig inntil videre, og vil fungere som en proxy til det nye endepunktet. Vi anbefaler likevel å bytte til det nye endepunktet.  Større eller ikke-kompatible endringer i APIet vil bli annonsert med minst 3 måneder forvarsel på <a href=\"https://status.kartverket.no\">https://status.kartverket.no</a>.     
 *
 * The version of the OpenAPI document: 1.1
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`navn_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NavnGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`navneobjekttyper_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NavneobjekttyperGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`punkt_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PunktGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sprak_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SprakGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sted_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StedGetError {
    UnknownValue(serde_json::Value),
}


/// Søk etter et spesifikt navn (skrivemåte/stedsnavn). Returen er sortert etter stedets kategorisering innenfor Sentralt stedsnavnsregister (et fylke kommer f.eks. før en bekk). Innenfor hver kategori er så returen sortert etter hvor godt det matcher søkebegrepet. <p>For eksempel ?sok=Trondheim*&fuzzy=false</p>
pub async fn navn_get(configuration: &configuration::Configuration, sok: Option<&str>, fuzzy: Option<bool>, fnr: Option<Vec<String>>, knr: Option<Vec<String>>, kommunenavn: Option<&str>, fylkesnavn: Option<&str>, sprak: Option<&str>, utkoordsys: Option<i32>, treff_per_side: Option<i32>, side: Option<i32>, filtrer: Option<&str>) -> Result<models::ReturSkrivemate, Error<NavnGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_sok = sok;
    let p_query_fuzzy = fuzzy;
    let p_query_fnr = fnr;
    let p_query_knr = knr;
    let p_query_kommunenavn = kommunenavn;
    let p_query_fylkesnavn = fylkesnavn;
    let p_query_sprak = sprak;
    let p_query_utkoordsys = utkoordsys;
    let p_query_treff_per_side = treff_per_side;
    let p_query_side = side;
    let p_query_filtrer = filtrer;

    let uri_str = format!("{}/navn", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_sok {
        req_builder = req_builder.query(&[("sok", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_fuzzy {
        req_builder = req_builder.query(&[("fuzzy", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_fnr {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("fnr".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("fnr", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_query_knr {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("knr".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("knr", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_query_kommunenavn {
        req_builder = req_builder.query(&[("kommunenavn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_fylkesnavn {
        req_builder = req_builder.query(&[("fylkesnavn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sprak {
        req_builder = req_builder.query(&[("sprak", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_utkoordsys {
        req_builder = req_builder.query(&[("utkoordsys", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_treff_per_side {
        req_builder = req_builder.query(&[("treffPerSide", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_side {
        req_builder = req_builder.query(&[("side", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filtrer {
        req_builder = req_builder.query(&[("filtrer", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ReturSkrivemate`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ReturSkrivemate`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<NavnGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Vis alle navneobjekttyper (f.eks by, elv, kirke) som et sted kan ha. Man kan filtrere på navneobjekttypekoder i noen søk, dette er en oversikt over de gyldige alternativene.
pub async fn navneobjekttyper_get(configuration: &configuration::Configuration, ) -> Result<Vec<models::Navneobjekttype>, Error<NavneobjekttyperGetError>> {

    let uri_str = format!("{}/navneobjekttyper", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Navneobjekttype&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Navneobjekttype&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<NavneobjekttyperGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gjør et geografisk søk etter de nærmeste stedene. Vær obs på at et sted kan ha flere stedsnavn og at hvert stedsnavn kan ha flere likestilte skrivemåter. Returen er sortert etter stedets kategorisering innenfor Sentralt stedsnavnsregister slik at det mest \"nærliggende\" stedet kommer først (en bekk kommer f.eks. før et fylke). Innenfor hver kategori er så returen sortert etter distanse til punktet som man søkte etter.  <p>For eksempel ?nord=60.5&ost=11.12&koordsys=4258&radius=1000</p>
pub async fn punkt_get(configuration: &configuration::Configuration, nord: f64, ost: f64, koordsys: i32, radius: Option<i32>, utkoordsys: Option<i32>, treff_per_side: Option<i32>, side: Option<i32>, filtrer: Option<&str>) -> Result<models::ReturPunkt, Error<PunktGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_nord = nord;
    let p_query_ost = ost;
    let p_query_koordsys = koordsys;
    let p_query_radius = radius;
    let p_query_utkoordsys = utkoordsys;
    let p_query_treff_per_side = treff_per_side;
    let p_query_side = side;
    let p_query_filtrer = filtrer;

    let uri_str = format!("{}/punkt", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("nord", &p_query_nord.to_string())]);
    req_builder = req_builder.query(&[("ost", &p_query_ost.to_string())]);
    req_builder = req_builder.query(&[("koordsys", &p_query_koordsys.to_string())]);
    if let Some(ref param_value) = p_query_radius {
        req_builder = req_builder.query(&[("radius", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_utkoordsys {
        req_builder = req_builder.query(&[("utkoordsys", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_treff_per_side {
        req_builder = req_builder.query(&[("treffPerSide", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_side {
        req_builder = req_builder.query(&[("side", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filtrer {
        req_builder = req_builder.query(&[("filtrer", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ReturPunkt`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ReturPunkt`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PunktGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Man kan filtrere på språkkoder i noen søk, dette er en oversikt over de gyldige alternativene.
pub async fn sprak_get(configuration: &configuration::Configuration, ) -> Result<Vec<models::Sprak>, Error<SprakGetError>> {

    let uri_str = format!("{}/sprak", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Sprak&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Sprak&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SprakGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Søk etter et sted. Et sted kan ha flere stedsnavn, hvert navn kan ha flere skrivemåter. Returen er sortert etter stedets kategorisering innenfor Sentralt stedsnavnsregister (et fylke kommer f.eks. før en bekk). Innenfor hver kategori er så returen sortert etter hvor godt det matcher søkebegrepet. <p>For eksempel ?sok=Trondheim*&knr=5001</p>
pub async fn sted_get(configuration: &configuration::Configuration, sok: Option<&str>, fuzzy: Option<bool>, fnr: Option<Vec<String>>, knr: Option<Vec<String>>, kommunenavn: Option<&str>, fylkesnavn: Option<&str>, stedsnummer: Option<i32>, navneobjekttype: Option<Vec<String>>, utkoordsys: Option<i32>, treff_per_side: Option<i32>, side: Option<i32>, filtrer: Option<&str>) -> Result<models::ReturSted, Error<StedGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_sok = sok;
    let p_query_fuzzy = fuzzy;
    let p_query_fnr = fnr;
    let p_query_knr = knr;
    let p_query_kommunenavn = kommunenavn;
    let p_query_fylkesnavn = fylkesnavn;
    let p_query_stedsnummer = stedsnummer;
    let p_query_navneobjekttype = navneobjekttype;
    let p_query_utkoordsys = utkoordsys;
    let p_query_treff_per_side = treff_per_side;
    let p_query_side = side;
    let p_query_filtrer = filtrer;

    let uri_str = format!("{}/sted", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_sok {
        req_builder = req_builder.query(&[("sok", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_fuzzy {
        req_builder = req_builder.query(&[("fuzzy", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_fnr {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("fnr".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("fnr", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_query_knr {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("knr".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("knr", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_query_kommunenavn {
        req_builder = req_builder.query(&[("kommunenavn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_fylkesnavn {
        req_builder = req_builder.query(&[("fylkesnavn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_stedsnummer {
        req_builder = req_builder.query(&[("stedsnummer", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_navneobjekttype {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("navneobjekttype".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("navneobjekttype", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_query_utkoordsys {
        req_builder = req_builder.query(&[("utkoordsys", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_treff_per_side {
        req_builder = req_builder.query(&[("treffPerSide", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_side {
        req_builder = req_builder.query(&[("side", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filtrer {
        req_builder = req_builder.query(&[("filtrer", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ReturSted`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ReturSted`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StedGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

